Chapter7 Input and Output
7.1 Standard I/O
7.1.1 The fopen() Function
Next, the program uses fopen() to open the file. This function is declared in stdio.h . Its
first argument is the name of the file to be opened; more exactly, it is the address of a string
containing that name. The second argument is a string identifying the mode in which the file
is to be opened. The C library provides for several possibilities, as shown in Table：
Mode 	String Meaning
"r" 	Open a text file for reading.
"w" 	Open a text file for writing, truncating an existing file to zero length, or creating
	the file if it does not exist.
"a" 	Open a text file for writing, appending to the end of an existing file, or creating
	the file if it does not exist.
"r+" 	Open a text file for update (that is, for both reading and writing).
"w+" 	Open a text file for update (reading and writing), first truncating the file to
	zero length if it exists or creating the file if it does not exist.
"a+" 	Open a text file for update (reading and writing), appending to the end of an
	existing file, or creating the file if it does not yet exist; the whole file can be
	read, but writing can only be appended.
"rb" , 	Like the preceding modes, except they use binary mode instead of text mode.
"wb" , 
"ab" ,
"ab+" , 
"a+b" ,
"wb+" , 
"w+b" ,
"ab+" , 
"a+b"
"wx" , 	(C11) Like the non-x modes, except they fail if the file already exists and they
"wbx" ,	open a file in exclusive mode, if possible.
"w+x" , 
"wb+x" 
or
"w+bx"

7.1.2 The getc() and putc() Functions
The two functions getc() and putc() work very much like getchar() and putchar() . The
difference is that you must tell these newcomers which file to use. So the following old standby
means “get a character from the standard input”:
ch = getchar();
However, this statement means “get a character from the file identified by fp ”:
ch = getc(fp);
Similarly, this statement means “put the character ch into the file identified by the FILE
pointer fpout ”:
putc(ch, fpout);
In the putc() argument list, the character comes first, and then the file pointer.
Listing 13.1 uses stdout for the second argument of putc() . It is defined in stdio.h as being
the file pointer associated with the standard output, so putc(ch,stdout) is the same as
putchar(ch) . Indeed, the latter function is normally defined as being the former. Similarly,
getchar() is defined as being getc() using the standard input.
You may wonder why this example uses putc() instead of putchar() . One reason is to introduce
the putc() function. The other is that you can easily convert this program to produce file
output by using an argument other than stdout .

7.1.3 End-of-File
A program reading data from a file needs to stop when it reaches the end of the file. How can
a program tell if it has reached the end? The getc() function returns the special value EOF if it
tries to read a character and discovers it has reached the end of the file. So a C program discovers
it has reached the end of a file only after it tries to read past the end of the file. (This is
unlike the behavior of some languages, which use a special function to test for end-of-file before
attempting a read.)
To avoid problems attempting to read an empty file, you should use an entry-condition loop
(not a do while loop) for file input. Because of the design of getc() (and other C input
functions), a program should attempt the first read before entering the body of the loop. So the
following design is good:
// good design #1
int ch; // int to hold EOF
FILE * fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp); // get initial input
while (ch != EOF)
{
	putchar(ch); // process input
	ch = getc(fp); // get next input
}

This can be condensed to the following design:
// good design #2
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (( ch = getc(fp)) != EOF)
{
	putchar(ch); // process input
}

Because the input statement is part of the while test condition, it is executed before the
program enters the body of the loop.
You should avoid a design of this sort:
// bad design (two problems)
int ch;
FILE * fp;
fp = fopen("wacky.txt", "r");
while (ch != EOF) // ch undetermined value first use
{
	ch = getc(fp); // get input
	putchar(ch); // process input
}

The first problem is that the first time ch is compared with EOF , it has not yet been assigned a
value. The second problem is that if getc() does return EOF , the loop tries to process EOF as
if it were a valid character. These defects are fixable. For example, you could initialize ch to a
dummy value and stick an if statement inside the loop, but why bother when good designs
are already available.
These cautions carry over to the other input functions. They also return an error signal (either
EOF or the NULL pointer) after running into the end of a file.

7.1.4 The fclose() Function
The fclose(fp) function closes the file identified by fp , flushing buffers as needed. For a
program less casual than this one, you would check to see whether the file had been closed
successfully. The function fclose() returns a value of 0 if successful, and EOF if not:
if (fclose(fp) != 0)
printf("Error in closing file %s\n", argv[1]);
The fclose() function can fail if, for example, the disk is full, a removable storage device has
been removed, or there has been an I/O error.

7.1.5 Pointers to the Standard Files
The stdio.h file associates three file pointers with the three standard files automatically
opened by C programs:
Standard File 	File Pointer 	Normally
Standard input 	stdin 		Your keyboard
Standard output stdout 		Your screen
Standard error 	stderr 		Your screen
These pointers are all type pointer-to- FILE , so they can be used as arguments to the standard
I/O functions, just as fp was in the example. Let’s move on to an example that creates a new
file and writes to it.

Chapter7 Input and Output
7.2 File I/O: fprintf(), fscanf(), fgets(), and fputs()
7.2.1 The fprintf() and fscanf() Functions
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 41
int main(void)
{
	FILE *fp;
	char words[MAX];
	if ((fp = fopen("wordy", "a+")) == NULL)
	{
		fprintf(stdout,"Can't open \"wordy\" file.\n");
		exit(EXIT_FAILURE);
	}
	puts("Enter words to add to the file; press the #");
	puts("key at the beginning of a line to terminate.");
	while ((fscanf(stdin,"%40s", words) == 1) && (words[0] != '#'))
	fprintf(fp, "%s\n", words);
	puts("File contents:");
	rewind(fp); /* go back to beginning of file */
	while (fscanf(fp,"%s",words) == 1)
		puts(words);
	puts("Done!");
	if (fclose(fp) != 0)
	fprintf(stderr,"Error closing file\n");
	return 0;
}

This program enables you to add words to a file. By using the "a+" mode, the program can
both read and write in the file. The first time the program is used, it creates the wordy file and
enables you to place words in it, one word per line. When you use the program subsequently,
it enables you to add (append) words to the previous contents. The append mode only enables
you to add material to the end of the file, but the "a+" mode does enable you to read the
whole file. The rewind() command takes the program to the file beginning so that the final
while loop can print the file contents. Note that rewind() takes a file pointer argument.

7.2.2 The fgets() and fputs() Functions
You met fgets() in Chapter 11 . The first argument, as with the banished gets() , is the
address (type char * ) where input should be stored. The second argument is an integer representing
the maximum size of the input string. The final argument is the file pointer identifying
the file to be read. A function call, then, looks like this:
fgets(buf, STLEN, fp);
Here, buf is the name of a char array, STLEN is the maximum size of the string, and fp is the
pointer-to- FILE .
As we saw earlier, the fgets() function reads input through the first newline character, until
one fewer than the upper limit of characters is read, or until the end-of-file is found; fgets()
then adds a terminating null character to form a string. Therefore, the upper limit represents
the maximum number of characters plus the null character. If fgets() reads in a whole line
before running into the character limit, it places the newline character, marking the end of the
line into the string, just before the null character. The fgets() function returns the value NULL
when it encounters EOF . You can use this to check for the end of a file. Otherwise, it returns
the address passed to it.
The fputs() function takes two arguments: first, an address of a string and then a file pointer.
It writes the string found at the pointed-to location into the indicated file. Unlike puts() ,
fputs() does not append a newline when it prints. A function call looks like this:
fputs(buf, fp);
Here, buf is the string address, and fp identifies the target file.
Because fgets() keeps the newline and fputs() doesn’t add one, they work well in tandem.

Chapter7 Input and Output
7.3 Adventures in Random Access: fseek() and ftell()
7.3.1 How fseek() and ftell() Work
The fseek() function enables you to treat a file like an array and move directly to any particular
byte in a file opened by fopen() . To see how it works, let’s create a program
that displays a file in reverse order. Note that fseek() has three arguments and returns
an int value. The ftell() function returns the current position in a file as a long value.
#include <stdio.h>
#include <stdlib.h>
#define CNTL_Z '\032' /* eof marker in DOS text files */
#define SLEN 81
int main(void)
{
	char file[SLEN];
	char ch;
	FILE *fp;
	long count, last;
	puts("Enter the name of the file to be processed:");
	scanf("%80s", file);
	if ((fp = fopen(file,"rb")) == NULL)
	{ /* read-only mode */
		printf("reverse can't open %s\n", file);
		exit(EXIT_FAILURE);
	}
	fseek(fp, 0L, SEEK_END); /* go to end of file */
	last = ftell(fp);
	for (count = 1L; count <= last; count++)
	{
		fseek(fp, -count, SEEK_END); /* go backward */
		ch = getc(fp);
		if (ch != CNTL_Z && ch != '\r') /* MS-DOS files */
			putchar(ch);
	}
	putchar('\n');
	fclose(fp);
	return 0;
}

Here is the output for a sample file:
Enter the name of the file to be processed:
Cluv
.C ni eno naht ylevol erom margorp a
ees reven llahs I taht kniht I
This program uses the binary mode so that it can deal with both MS-DOS text and Unix files.
However, it may not work correctly in an environment that uses some other format for text
files.

7.3.2 Binary Versus Text Mode
We designed Listing 13.4 to work in both the Unix and the MS-DOS environments. Unix has
only one file format, so no special adjustments are needed. MS-DOS, however, does require
extra attention. Many MS-DOS editors mark the end of a text file with the character Ctrl+Z.
When such a file is opened in the text mode, C recognizes this character as marking the end of
the file. When the same file is opened in the binary mode, however, the Ctrl+Z character is just
another character in the file, and the actual end-of-file comes later. It might come immediately
after the Ctrl+Z, or the file could be padded with null characters to make the size a multiple of,
say, 256. Null characters don’t print under DOS, and we included code to prevent the program
from trying to print the Ctrl+Z character.
Another difference is one we’ve mentioned before: MS-DOS represents a text file newline with
the \r\n combination. A C program opening the same file in a text mode “sees” \r\n as a
simple \n , but, when using the binary mode, the program sees both characters. Therefore, we
included coding to suppress printing \r . Because a Unix text file normally contains neither
Ctrl+Z nor \r , this extra coding does not affect most Unix text files.
The ftell() function may work differently in the text mode than in the binary mode. Many
systems have text file formats that are different enough from the Unix model that a byte
count from the beginning of the file is not a meaningful quantity. ANSI C states that, for the
text mode, ftell() returns a value that can be used as the second argument to fseek() . For
MS-DOS, for example, ftell() can return a count that sees \r\n as a single byte.

7.3.3 Portability
Ideally, fseek() and ftell() should conform to the Unix model. However, differences in real
systems sometimes make this impossible. Therefore, ANSI provides lowered expectations for
these functions. Here are some limitations:
■ In the binary mode, implementations need not support the SEEK_END mode.A more portable approach 
is to read the whole file byte-by-byte until the end. But reading the file sequentially to find 
the end is slower than simply jumping to the end. The C preprocessor conditional compilation
directives, discussed in Chapter 16 , “The C Preprocessor and the C Library,” provide a
systematic way to handle alternative code choices.
■ In the text mode, the only calls to fseek() that are guaranteed to work are these:
Function 				Call Effect
fseek(file, 0L, SEEK_SET) 		Go to the beginning of the file.
fseek(file, 0L, SEEK_CUR) 		Stay at the current position.
fseek(file, 0L, SEEK_END) 		Go to the file’s end.
fseek(file,ftell-pos, SEEK_SET) 	Go to position ftell-pos from the beginning; ftellpos
					is a value returned by ftell() .
Fortunately, many common environments allow stronger implementations of these functions.

7.3.4 The fgetpos() and fsetpos() Functions
One potential problem with fseek() and ftell() is that they limit file sizes to values that can
be represented by type long . Perhaps two-billion bytes seem more than adequate, but the everincreasing
capacities of storage devices makes larger files possible. ANSI C introduced two new
positioning functions designed to work with larger file sizes. Instead of using a long value to
represent a position, it uses a new type, called fpos_t (for file position type) for that purpose.
The fpos_t type is not a fundamental type; rather, it is defined in terms of other types. A variable
or data object of fpos_t type can specify a location within a file, and it cannot be an array
type, but its nature is not specified beyond that. Implementations can then provide a type
to meet the needs of a particular platform; the type could, for example, be implemented as a
structure.
ANSI C does define how fpos_t is used. The fgetpos() function has this prototype:
int fgetpos(FILE * restrict stream, fpos_t * restrict pos);
When called, it places an fpos_t value in the location pointed to by pos ; the value describes a
location in the file. The function returns zero if successful and a nonzero value for failure.
The fsetpos() function has this prototype:
int fsetpos(FILE *stream, const fpos_t *pos);
When called, it uses the fpos_t value in the location pointed to by pos to set the file pointer
to the location indicated by that value. The function returns zero if successful and a nonzero
value for failure. The fpos_t value should have been obtained by a previous call to fgetpos() .

Chapter7 Input and Output
7.4 Other Standard I/O Functions
7.4.1 The int ungetc(int c, FILE *fp) Function
The int ungetc() function pushes the character specified by c back onto the input stream.
If you push a character onto the input stream, the next call to a standard input function reads
that character. Suppose, for example, that you want a function to read characters
up to, but not including, the next colon. You can use getchar() or getc() to read characters
until a colon is read and then use ungetc() to place the colon back in the input stream.
The ANSI C standard guarantees only one pushback at a time. If an implementation permits
you to push back several characters in a row, the input functions read them in the reversed
order of pushing.

7.4.2 The int fflush() Function
The prototype for fflush( ) is this:
int fflush(FILE *fp);
Calling the fflush() function causes any unwritten data in the output buffer to be sent to the
output file identified by fp. This process is called flushing a buffer. If fp is the null pointer, all
output buffers are flushed. The effect of using fflush() on an input stream is undefined. You
can use it with an update stream (any of the read-write modes), provided that the most recent
operation using the stream was not input.

7.4.3 The int setvbuf() Function
The prototype for setvbuf() is this:
int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);
The setvbuf() function sets up an alternative buffer to be used by the standard I/O functions.
It is called after the file has been opened and before any other operations have been performed
on the stream. The pointer fp identifies the stream, and buf points to the storage to be used.
If the value of buf is not NULL , you must create the buffer. For instance, you could declare an
array of 1,024 char s and pass the address of that array. However, if you use NULL for the value
of buf , the function allocates a buffer itself. The size variable tells setvbuf() how big the
array is. (The size_t type is a derived integer type; see Chapter 5 , “Operators, Expressions, and
Statements.”) The mode is selected from the following choices: IOFBF means fully buffered
(buffer flushed when full), IOLBF means line-buffered (buffer flushed when full or when a
newline is written), and IONBF means nonbuffered. The function returns zero if successful,
nonzero otherwise.
Suppose you have a program that works with stored data objects having, say, a size of 3,000
bytes each. You could use setvbuf() to create a buffer whose size is a multiple of the data
object’s size.

7.4.4 Binary I/O: fread() and fwrite()
The fread() and fwrite() functions are next on the list, but first some background. The
standard I/O functions you’ve used to this point are text oriented, dealing with characters and
strings. What if you want to save numeric data in a file? True, you can use fprintf() and the
%f format to save a floating-point value, but then you are saving it as a sequence of characters.
For example, the code
double num = 1./3.;
fprintf(fp,"%f", num);
saves num as a sequence of eight characters: 0.333333 . Using a %.2f specifier saves it as four
characters: 0.33 . Using a %.12f specifier saves it as 14 characters: 0.333333333333 . Changing
the specifier alters the amount of space needed to store the value; it can also result in different
values being stored. After the value of num is stored as 0.33 , there is no way to get back the
full precision when the file is read. In general, fprintf() converts numeric values to character
data, possibly altering the value.
The most accurate and consistent way to store a number is to use the same pattern of bits that
the computer does. Therefore, a double value should be stored in a size double unit. When
data is stored in a file using the same representation that the program uses, we say that the data
is stored in binary form . There is no conversion from numeric forms to character sequences. For
standard I/O, the fread() and fwrite() functions provide this binary service.
Actually, as you probably recall, all data is stored in binary form. Even characters are stored
using the binary representation of the character code. However, if all data in the file is interpreted
as character codes, we say that the file contains text data. If some or all of the data is
interpreted as numeric data in binary form, we say that the file contains binary data. (Also, files
in which the data represents machine-language instructions are binary files.)
The uses of the terms binary and text can get confusing. ANSI C recognizes two modes for
opening files: binary and text. Many operating systems recognize two file formats: binary and
text. Information can be stored or read as binary data or as text data. These are all related,
but not identical. You can open a text format file in the binary mode. You can store text in
a binary format file. You can use getc() to copy files containing binary data. In general,
however, you use the binary mode to store binary data in a binary format file. Similarly, you
most often use text data in text files opened in the text format. (Files produced by word processors
typically are binary files because they contain a lot of nontext information describing fonts
and formatting.)

7.4.5 The size_t fwrite() Function
The prototype for fwrite() is this:
size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,
FILE * restrict fp);
The fwrite() function writes binary data to a file. The size_t type is defined in terms of the
standard C types. It is the type returned by the sizeof operator. Typically, it is unsigned int ,
but an implementation can choose another type. The pointer ptr is the address of the chunk
of data to be written. Also, size represents the size, in bytes, of the chunks to be written, and
nmemb represents the number of chunks to be written. As usual, fp identifies the file to be
written to. For instance, to save a data object (such as an array) that is 256 bytes in size, you
can do this:
char buffer[256];
fwrite(buffer, 256, 1, fp);
This call writes one chunk of 256 bytes from buffer to the file. Or, to save an array of 10
double values, you can do this:
double earnings[10];
fwrite(earnings, sizeof (double), 10, fp);
This call writes data from the earnings array to the file in 10 chunks, each of size double .
You probably noticed the odd declaration of const void * restrict ptr in the fwrite()
prototype. One problem with fwrite() is that its first argument is not a fixed type. For
instance, the first example used buffer , which is type pointer-to- char , and the second
example used earnings , which is type pointer-to- double . Under ANSI C function prototyping,
these actual arguments are converted to the pointer-to- void type, which acts as a sort of catchall
type for pointers. (Pre-ANSI C uses type char * for this argument, requiring you to typecast
actual arguments to that type.)
The fwrite() function returns the number of items successfully written. Normally, this equals
nmemb , but it can be less if there is a write error.

7.4.6 The size_t fread() Function
The prototype for fread() is this:
size_t fread(void * restrict ptr, size_t size, size_t nmemb,
FILE * restrict fp);
The fread() function takes the same set of arguments that fwrite() does. This time ptr is
the address of the memory storage into which file data is read, and fp identifies the file to be
read. Use this function to read data that was written to a file using fwrite() . For example, to
recover the array of 10 doubles saved in the previous example, use this call:
double earnings[10];
fread(earnings, sizeof (double), 10, fp);
This call copies 10 size double values into the earnings array.
The fread() function returns the number of items successfully read. Normally, this equals
nmemb , but it can be less if there is a read error or if the end-of-file is reached.

7.4.7 The int feof(FILE *fp) and int ferror(FILE *fp) Functions
When the standard input functions return EOF , this usually means they have reached the end
of a file. However, it can also indicate that a read error has occurred. The feof() and ferror()
functions enable you to distinguish between the two possibilities. The feof() function returns
a nonzero value if the last input call detected the end-of-file, and it returns zero otherwise. The
ferror() function returns a nonzero value if a read or write error has occurred, and it returns
zero otherwise.

7.4.8 An fread() and fwrite() Example
Let’s use some of these functions in a program that appends the contents from a list of files
to the end of another file. One problem is passing the file information to the program. This
can be done interactively or by using command-line arguments. We’ll take the first approach,
which suggests a plan along the following lines:
■ Request a name for the destination file and open it.
■ Use a loop to request source files.
■ Open each source file in turn in the read mode and add it to the append file.
To illustrate setvbuf() , we’ll use it to specify a different buffer size. The next stage of refinement
examines opening the append file. We will use the following steps:
1. Open the destination file in the append mode.
2. If this cannot be done, quit.
3. Establish a 4,096-byte buffer for this file.
4. If this cannot be done, quit.
Similarly, we can refine the copying portion by doing the following for each file:
■ If it is the same as the append file, skip to the next file.
■ If it cannot be opened in the read mode, skip to the next file.
■ Add the contents of the file to the append file.
For a grand finale, the program rewinds the append file to the beginning and displays the contents.